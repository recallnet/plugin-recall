{"version":3,"sources":["../src/services/recall.service.ts","../src/utils.ts","../../../node_modules/uuid/dist/esm-node/rng.js","../../../node_modules/uuid/dist/esm-node/regex.js","../../../node_modules/uuid/dist/esm-node/validate.js","../../../node_modules/uuid/dist/esm-node/stringify.js","../../../node_modules/uuid/dist/esm-node/v4.js","../src/actions/buy-credit.ts","../src/actions/get-balance.ts","../src/actions/get-account.ts","../src/actions/list-buckets.ts","../src/actions/create-bucket.ts","../src/actions/add-object.ts","../src/actions/get-object.ts","../src/providers/cot.ts","../src/index.ts"],"sourcesContent":["import {\n  elizaLogger,\n  Service,\n  ServiceType,\n  DatabaseAdapter,\n  IAgentRuntime,\n} from '@elizaos/core';\nimport { ChainName, getChain, testnet } from '@recallnet/chains';\nimport { AccountInfo } from '@recallnet/sdk/account';\nimport { ListResult } from '@recallnet/sdk/bucket';\nimport { RecallClient, walletClientFromPrivateKey } from '@recallnet/sdk/client';\nimport { CreditAccount } from '@recallnet/sdk/credit';\nimport { Address, Hex, parseEther, TransactionReceipt } from 'viem';\nimport {\n  getUnsyncedLogsPostgres,\n  getUnsyncedLogsSqlite,\n  markLogsAsSyncedPostgres,\n  markLogsAsSyncedSqlite,\n} from '../utils.ts';\n\ntype Result<T = unknown> = {\n  result: T;\n  meta?: {\n    tx?: TransactionReceipt;\n  };\n};\n\nconst privateKey = process.env.RECALL_PRIVATE_KEY as Hex;\nconst envAlias = process.env.RECALL_BUCKET_ALIAS as string;\nconst envPrefix = process.env.RECALL_COT_LOG_PREFIX as string;\nconst network = process.env.RECALL_NETWORK as string;\nconst intervalPeriod = process.env.RECALL_SYNC_INTERVAL as string;\nconst batchSize = process.env.RECALL_BATCH_SIZE as string;\n\nexport class RecallService extends Service {\n  static serviceType: ServiceType = 'recall' as ServiceType;\n  private client: RecallClient;\n  private runtime: IAgentRuntime;\n  private syncInterval: NodeJS.Timeout | undefined;\n  private alias: string;\n  private prefix: string;\n  private intervalMs: number;\n  private batchSizeKB: number;\n\n  getInstance(): RecallService {\n    return RecallService.getInstance();\n  }\n\n  async initialize(_runtime: IAgentRuntime): Promise<void> {\n    try {\n      if (!privateKey) {\n        throw new Error('RECALL_PRIVATE_KEY is required');\n      }\n      if (!envAlias) {\n        throw new Error('RECALL_BUCKET_ALIAS is required');\n      }\n      if (!envPrefix) {\n        throw new Error('RECALL_COT_LOG_PREFIX is required');\n      }\n      const chain = network ? getChain(network as ChainName) : testnet;\n      const wallet = walletClientFromPrivateKey(privateKey, chain);\n      this.client = new RecallClient({ walletClient: wallet });\n      this.alias = envAlias;\n      this.prefix = envPrefix;\n      this.runtime = _runtime;\n      // Use user-defined sync interval and batch size, if provided\n      this.intervalMs = intervalPeriod ? parseInt(intervalPeriod, 10) : 2 * 60 * 1000;\n      this.batchSizeKB = batchSize ? parseInt(batchSize, 10) : 4;\n\n      // Ensure isSynced column exists in logs table\n      await this.ensureRequiredColumns();\n\n      this.startPeriodicSync(this.intervalMs, this.batchSizeKB);\n      elizaLogger.success('RecallService initialized successfully, starting periodic sync.');\n    } catch (error) {\n      elizaLogger.error(`Error initializing RecallService: ${error.message}`);\n    }\n  }\n\n  /**\n   * Ensures that the isSynced column exists in the logs table.\n   * If it doesn't exist, it adds the column with a default value of false.\n   */\n  private async ensureRequiredColumns(): Promise<void> {\n    try {\n      const db: any = this.runtime.databaseAdapter;\n\n      // First, check for isSynced column\n      await this.ensureColumn(db, 'isSynced', 'BOOLEAN', 'INTEGER', 'FALSE', '0');\n\n      // Then, check for agentId column\n      await this.ensureColumn(db, 'agentId', 'TEXT', 'TEXT', 'NULL', 'NULL');\n    } catch (error) {\n      elizaLogger.error(`Error ensuring required columns: ${error.message}`);\n      throw error;\n    }\n  }\n\n  private async ensureColumn(\n    db: any,\n    columnName: string,\n    pgType: string,\n    sqliteType: string,\n    pgDefault: string,\n    sqliteDefault: string,\n  ): Promise<void> {\n    try {\n      // Check if the column exists\n      let columnExists = false;\n\n      if ('pool' in db) {\n        // PostgreSQL\n        const result = await db.pool.query(\n          `\n          SELECT column_name \n          FROM information_schema.columns \n          WHERE table_name='logs' AND column_name=$1\n        `,\n          [columnName],\n        );\n        columnExists = result.rowCount > 0;\n      } else if ('db' in db) {\n        // SQLite\n        const result = db.db.prepare(`PRAGMA table_info(logs)`).all();\n        columnExists = result.some((col) => col.name === columnName);\n      } else {\n        throw new Error('Unsupported database adapter');\n      }\n\n      // Add the column if it doesn't exist\n      if (!columnExists) {\n        elizaLogger.info(`Adding ${columnName} column to logs table`);\n\n        if ('pool' in db) {\n          // PostgreSQL\n          await db.pool.query(`\n            ALTER TABLE logs \n            ADD COLUMN \"${columnName}\" ${pgType} DEFAULT ${pgDefault}\n          `);\n        } else if ('db' in db) {\n          // SQLite\n          await db.db\n            .prepare(\n              `\n            ALTER TABLE logs \n            ADD COLUMN ${columnName} ${sqliteType} DEFAULT ${sqliteDefault}\n          `,\n            )\n            .run();\n        }\n\n        elizaLogger.info(`Successfully added ${columnName} column to logs table`);\n      } else {\n        elizaLogger.info(`${columnName} column already exists in logs table`);\n      }\n    } catch (error) {\n      elizaLogger.error(`Error ensuring ${columnName} column: ${error.message}`);\n      throw error;\n    }\n  }\n  /**\n   * Utility function to handle timeouts for async operations.\n   * @param promise The promise to execute.\n   * @param timeoutMs The timeout in milliseconds.\n   * @param operationName The name of the operation for logging.\n   * @returns The result of the promise.\n   */\n  async withTimeout<T>(promise: Promise<T>, timeoutMs: number, operationName: string): Promise<T> {\n    let timeoutId: NodeJS.Timeout;\n\n    const timeoutPromise = new Promise<T>((_, reject) => {\n      timeoutId = setTimeout(() => {\n        reject(new Error(`${operationName} operation timed out after ${timeoutMs}ms`));\n      }, timeoutMs);\n    });\n\n    try {\n      const result = await Promise.race([promise, timeoutPromise]);\n      clearTimeout(timeoutId!);\n      return result;\n    } catch (error) {\n      clearTimeout(timeoutId!);\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the account information for the current user.\n   * @returns The account information.\n   */\n  public async getAccountInfo(): Promise<AccountInfo> | undefined {\n    try {\n      const info = await this.client.accountManager().info();\n      return info.result;\n    } catch (error) {\n      elizaLogger.error(`Error getting account info: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Lists all buckets in Recall.\n   * @returns The list of buckets.\n   */\n  public async listBuckets(): Promise<ListResult> | undefined {\n    try {\n      const info = await this.client.bucketManager().list();\n      return info.result;\n    } catch (error) {\n      elizaLogger.error(`Error listing buckets: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the credit information for the account.\n   * @returns The credit information.\n   */\n  public async getCreditInfo(): Promise<CreditAccount> | undefined {\n    try {\n      const info = await this.client.creditManager().getAccount();\n      return info.result;\n    } catch (error) {\n      elizaLogger.error(`Error getting credit info: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Buys credit for the account.\n   * @param amount The amount of credit to buy.\n   * @returns The result of the buy operation.\n   */\n  public async buyCredit(amount: string): Promise<Result> {\n    try {\n      const info = await this.client.creditManager().buy(parseEther(amount));\n      return info; // Return the full Result object\n    } catch (error) {\n      elizaLogger.error(`Error buying credit: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Gets or creates a log bucket in Recall.\n   * @param bucketAlias The alias of the bucket to retrieve or create.\n   * @returns The address of the log bucket.\n   */\n  public async getOrCreateBucket(bucketAlias: string): Promise<Address> {\n    try {\n      elizaLogger.info(`Looking for bucket with alias: ${bucketAlias}`);\n\n      // Try to find the bucket by alias\n      const buckets = await this.client.bucketManager().list();\n      if (buckets?.result) {\n        const bucket = buckets.result.find((b) => b.metadata?.alias === bucketAlias);\n        if (bucket) {\n          elizaLogger.info(`Found existing bucket \"${bucketAlias}\" at ${bucket.addr}`);\n          return bucket.addr; // Return existing bucket address\n        } else {\n          elizaLogger.info(`Bucket with alias \"${bucketAlias}\" not found, creating a new one.`);\n        }\n      }\n\n      // Ensure bucketAlias is correctly passed during creation\n      const query = await this.client.bucketManager().create({\n        metadata: { alias: bucketAlias },\n      });\n\n      const newBucket = query.result;\n      if (!newBucket) {\n        elizaLogger.error(`Failed to create new bucket with alias: ${bucketAlias}`);\n        throw new Error(`Failed to create bucket: ${bucketAlias}`);\n      }\n\n      elizaLogger.info(`Successfully created new bucket \"${bucketAlias}\" at ${newBucket.bucket}`);\n      return newBucket.bucket;\n    } catch (error) {\n      elizaLogger.error(`Error in getOrCreateBucket: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Adds an object to a bucket.\n   * @param bucket The address of the bucket.\n   * @param key The key under which to store the object.\n   * @param data The data to store (string, File, or Uint8Array).\n   * @param options Optional parameters:\n   *   - overwrite: Whether to overwrite existing object with same key (default: false)\n   *   - ttl: Time-to-live in seconds (must be >= MIN_TTL if specified)\n   *   - metadata: Additional metadata key-value pairs\n   * @returns A Result object containing:\n   *   - result: Empty object ({})\n   *   - meta: Optional metadata including transaction receipt\n   * @throws {InvalidValue} If object size exceeds MAX_OBJECT_SIZE or TTL is invalid\n   * @throws {ActorNotFound} If the bucket or actor is not found\n   * @throws {AddObjectError} If the object addition fails\n   */\n  public async addObject(\n    bucket: Address,\n    key: string,\n    data: string | File | Uint8Array,\n    options?: { overwrite?: boolean },\n  ): Promise<Result> {\n    try {\n      const info = await this.client.bucketManager().add(bucket, key, data, {\n        overwrite: options?.overwrite ?? false,\n      });\n      return info; // Return the full Result object\n    } catch (error) {\n      elizaLogger.error(`Error adding object: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Gets an object from a bucket.\n   * @param bucket The address of the bucket.\n   * @param key The key under which the object is stored.\n   * @returns The data stored under the specified key.\n   */\n  public async getObject(bucket: Address, key: string): Promise<Uint8Array | undefined> {\n    try {\n      const info = await this.client.bucketManager().get(bucket, key);\n      return info.result;\n    } catch (error) {\n      elizaLogger.warn(`Error getting object: ${error.message}`);\n      // Return undefined instead of throwing to allow graceful handling of missing objects\n      return undefined;\n    }\n  }\n\n  /**\n   * Fetches unsynchronized logs based on the isSynced field.\n   * @returns Array of logs that haven't been synced yet.\n   */\n  async getUnsyncedLogs(): Promise<any[]> {\n    try {\n      const db: any = this.runtime.databaseAdapter;\n\n      if ('pool' in db) {\n        // PostgreSQL\n        return await getUnsyncedLogsPostgres(db.pool);\n      } else if ('db' in db) {\n        // SQLite\n        return await getUnsyncedLogsSqlite(db.db);\n      } else {\n        throw new Error('Unsupported database adapter');\n      }\n    } catch (error) {\n      elizaLogger.error(`Error getting unsynced logs: ${error.message}`);\n      return [];\n    }\n  }\n\n  /**\n   * Marks logs as synced in the database.\n   * @param logIds The IDs of the logs to mark as synced.\n   * @returns Whether the operation was successful.\n   */\n  async markLogsAsSynced(logIds: string[]): Promise<boolean> {\n    if (logIds.length === 0) {\n      return true;\n    }\n\n    try {\n      const db: any = this.runtime.databaseAdapter;\n\n      if ('pool' in db) {\n        // PostgreSQL\n        await markLogsAsSyncedPostgres(db.pool, logIds);\n      } else if ('db' in db) {\n        // SQLite\n        await markLogsAsSyncedSqlite(db.db, logIds);\n      } else {\n        throw new Error('Unsupported database adapter');\n      }\n\n      return true;\n    } catch (error) {\n      elizaLogger.error(`Error marking logs as synced: ${error.message}`);\n      return false;\n    }\n  }\n\n  async runRawQuery<R>(dbAdapter: DatabaseAdapter, query: string, params?: any[]): Promise<R[]> {\n    if ('pool' in dbAdapter) {\n      // PostgreSQL (uses pool.query)\n      return (await (dbAdapter as any).pool.query(query, params)).rows as R[];\n    } else if ('db' in dbAdapter) {\n      // SQLite (uses prepare + all)\n      return (dbAdapter as any).db.prepare(query).all(...(params || [])) as R[];\n    } else {\n      throw new Error('Unsupported database adapter');\n    }\n  }\n\n  /**\n   * Stores a batch of logs to Recall.\n   * @param bucketAddress The address of the bucket to store logs.\n   * @param batch The batch of logs to store.\n   * @param timestamp The timestamp to use in the key.\n   * @returns The key under which the logs were stored.\n   */\n  async storeBatchToRecall(\n    bucketAddress: Address,\n    batch: string[],\n    timestamp: string,\n  ): Promise<string | undefined> {\n    try {\n      const nextLogKey = `${this.prefix}${timestamp}.jsonl`;\n      const batchData = batch.join('\\n');\n\n      // Add 30 second timeout to the add operation\n      const addObject = await this.withTimeout(\n        this.client\n          .bucketManager()\n          .add(bucketAddress, nextLogKey, new TextEncoder().encode(batchData)),\n        30000, // 30 second timeout\n        'Recall batch storage',\n      );\n\n      if (!addObject?.meta?.tx) {\n        // Check for transaction receipt instead of result\n        elizaLogger.error('Recall API returned invalid response for batch storage');\n        return undefined;\n      }\n\n      elizaLogger.info(`Successfully stored batch at key: ${nextLogKey}`);\n      return nextLogKey;\n    } catch (error) {\n      if (error.message.includes('timed out')) {\n        elizaLogger.error(`Recall API timed out while storing batch`);\n      } else {\n        elizaLogger.error(`Error storing JSONL logs in Recall: ${error.message}`);\n      }\n      return undefined;\n    }\n  }\n\n  /**\n   * Syncs logs to Recall in batches.\n   * @param bucketAlias The alias of the bucket to store logs.\n   * @param batchSizeKB The maximum size of each batch in kilobytes.\n   */\n  async syncLogsToRecall(bucketAlias: string, batchSizeKB = 4): Promise<void> {\n    try {\n      // Add timeout to bucket creation/retrieval\n      const bucketAddress = await this.withTimeout(\n        this.getOrCreateBucket(bucketAlias),\n        15000, // 15 second timeout\n        'Get/Create bucket',\n      );\n\n      // Get logs that haven't been synced yet\n      const unsyncedLogs = await this.getUnsyncedLogs();\n\n      if (unsyncedLogs.length === 0) {\n        elizaLogger.info('No unsynced logs to process.');\n        return;\n      }\n\n      elizaLogger.info(`Found ${unsyncedLogs.length} unsynced logs.`);\n\n      let batch: string[] = [];\n      let batchSize = 0;\n      let processedLogIds: string[] = [];\n      let batchTimestamp = Date.now().toString();\n\n      // Sort logs by createdAt to ensure we process in chronological order\n      unsyncedLogs.sort(\n        (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime(),\n      );\n\n      for (const log of unsyncedLogs) {\n        try {\n          const parsedLog = JSON.parse(log.body);\n          const jsonlEntry = JSON.stringify({\n            userId: parsedLog.userId,\n            agentId: parsedLog.agentId,\n            userMessage: parsedLog.userMessage,\n            log: parsedLog.log,\n            createdAt: log.createdAt, // Include createdAt in the stored log\n          });\n\n          const logSize = new TextEncoder().encode(jsonlEntry).length;\n          elizaLogger.info(`Processing log entry of size: ${logSize} bytes`);\n          elizaLogger.info(`New batch size: ${batchSize + logSize} bytes`);\n\n          // If this log would make the batch exceed the size limit, store the current batch first\n          if (batchSize > 0 && batchSize + logSize > batchSizeKB * 1024) {\n            elizaLogger.info(\n              `Batch size ${batchSize + logSize} bytes exceeds ${batchSizeKB} KB limit. Attempting sync...`,\n            );\n\n            const logFileKey = await this.storeBatchToRecall(bucketAddress, batch, batchTimestamp);\n\n            if (logFileKey) {\n              elizaLogger.info(`Successfully synced batch of ${batch.length} logs`);\n\n              // Mark logs as synced\n              if (processedLogIds.length > 0) {\n                const success = await this.markLogsAsSynced(processedLogIds);\n                if (!success) {\n                  elizaLogger.warn(`Failed to mark logs as synced - will retry on next sync`);\n                }\n              }\n            } else {\n              elizaLogger.warn(\n                `Failed to sync batch of ${batch.length} logs - will retry on next sync`,\n              );\n              // Don't clear processedLogIds if sync failed\n              continue;\n            }\n\n            // Start a new batch\n            batch = [];\n            batchSize = 0;\n            processedLogIds = [];\n            batchTimestamp = Date.now().toString();\n          }\n\n          batch.push(jsonlEntry);\n          batchSize += logSize;\n          processedLogIds.push(log.id);\n        } catch (error) {\n          elizaLogger.error(`Error processing log entry ${log.id}: ${error.message}`);\n        }\n      }\n\n      // Store any remaining logs in the batch\n      if (batch.length > 0) {\n        elizaLogger.info(`Storing final batch of ${batch.length} logs (${batchSize} bytes)`);\n        const logFileKey = await this.storeBatchToRecall(bucketAddress, batch, batchTimestamp);\n\n        if (logFileKey) {\n          // Mark logs as synced\n          if (processedLogIds.length > 0) {\n            const success = await this.markLogsAsSynced(processedLogIds);\n            if (!success) {\n              elizaLogger.warn(`Failed to mark logs as synced - will retry on next sync`);\n            }\n          }\n        } else {\n          elizaLogger.warn(`Failed to sync final batch of ${batch.length} logs`);\n        }\n      }\n\n      const logSyncInterval =\n        this.intervalMs < 60000\n          ? `${this.intervalMs / 1000} seconds`\n          : `${this.intervalMs / 1000 / 60} minutes`;\n      elizaLogger.info(`Sync cycle complete. Next sync in ${logSyncInterval}.`);\n    } catch (error) {\n      if (error.message.includes('timed out')) {\n        elizaLogger.error(`Recall sync operation timed out: ${error.message}`);\n      } else {\n        elizaLogger.error(`Error in syncLogsToRecall: ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * Retrieve and order all chain-of-thought logs from Recall.\n   * @param bucketAlias The alias of the bucket to query.\n   * @returns An array of ordered chain-of-thought logs.\n   */\n  async retrieveOrderedChainOfThoughtLogs(bucketAlias: string): Promise<any[]> {\n    try {\n      const bucketAddress = await this.getOrCreateBucket(bucketAlias);\n      elizaLogger.info(`Retrieving chain-of-thought logs from bucket: ${bucketAddress}`);\n\n      // Query all objects with the designated prefix\n      const queryResult = await this.client\n        .bucketManager()\n        .query(bucketAddress, { prefix: this.prefix }); // Remove the extra '/'\n\n      if (!queryResult.result?.objects.length) {\n        elizaLogger.info(`No chain-of-thought logs found in bucket: ${bucketAlias}`);\n        return [];\n      }\n\n      // Extract log filenames and sort by timestamp\n      const logFiles = queryResult.result.objects\n        .map((obj) => obj.key)\n        .filter((key) => key.startsWith(this.prefix) && key.endsWith('.jsonl'))\n        .sort((a, b) => {\n          // Extract timestamps by removing prefix and .jsonl extension\n          const timeA = parseInt(a.slice(this.prefix.length, -6), 10);\n          const timeB = parseInt(b.slice(this.prefix.length, -6), 10);\n          return timeA - timeB;\n        });\n\n      elizaLogger.info(`Retrieving ${logFiles.length} ordered chain-of-thought logs...`);\n\n      let allLogs: any[] = [];\n\n      // Download and parse each log file\n      for (const logFile of logFiles) {\n        try {\n          const logData = await this.client.bucketManager().get(bucketAddress, logFile);\n          if (!logData.result) continue;\n\n          // Decode and split JSONL content\n          const decodedLogs = new TextDecoder().decode(logData.result).trim().split('\\n');\n          const parsedLogs = decodedLogs.map((line) => JSON.parse(line));\n\n          allLogs.push(...parsedLogs);\n        } catch (error) {\n          elizaLogger.error(`Error retrieving log file ${logFile}: ${error.message}`);\n        }\n      }\n\n      // Sort logs by createdAt if available, otherwise maintain file order\n      allLogs.sort((a, b) => {\n        if (a.createdAt && b.createdAt) {\n          return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();\n        }\n        return 0;\n      });\n\n      elizaLogger.info(\n        `Successfully retrieved and ordered ${allLogs.length} chain-of-thought logs.`,\n      );\n      return allLogs;\n    } catch (error) {\n      elizaLogger.error(`Error retrieving ordered chain-of-thought logs: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Starts the periodic log syncing.\n   * @param intervalMs The interval in milliseconds for syncing logs.\n   * @param batchSizeKB The maximum size of each batch in kilobytes.\n   */\n  public startPeriodicSync(intervalMs = 2 * 60 * 1000, batchSizeKB = 4): void {\n    if (this.syncInterval) {\n      elizaLogger.warn('Log sync is already running.');\n      return;\n    }\n\n    elizaLogger.info('Starting periodic log sync...');\n    this.syncInterval = setInterval(async () => {\n      try {\n        await this.syncLogsToRecall(this.alias, batchSizeKB);\n      } catch (error) {\n        elizaLogger.error(`Periodic log sync failed: ${error.message}`);\n      }\n    }, intervalMs);\n\n    // Perform an immediate sync on startup\n    this.syncLogsToRecall(this.alias, batchSizeKB).catch((error) =>\n      elizaLogger.error(`Initial log sync failed: ${error.message}`),\n    );\n  }\n\n  /**\n   * Stops the periodic log syncing.\n   */\n  public stopPeriodicSync(): void {\n    if (this.syncInterval) {\n      clearInterval(this.syncInterval);\n      this.syncInterval = undefined;\n      elizaLogger.info('Stopped periodic log syncing.');\n    }\n  }\n}\n","import { elizaLogger } from '@elizaos/core';\nimport { v4, UUID } from 'uuid';\n\nexport async function logMemoryPostgres(\n  db: any,\n  params: {\n    userId: UUID;\n    agentId: UUID;\n    roomId: UUID;\n    type: string;\n    body: string;\n  },\n): Promise<void> {\n  // First ensure the room exists\n  const roomCheck = await db.query('SELECT id FROM rooms WHERE id = $1', [params.roomId]);\n  if (roomCheck.rows.length === 0) {\n    // If room doesn't exist, create it\n    await db.query('INSERT INTO rooms (id) VALUES ($1)', [params.roomId]);\n  }\n\n  // Now we can safely insert the log\n  await db.query(\n    `INSERT INTO logs (id, body, \"userId\", \"agentId\", \"roomId\", type, \"isSynced\")\n       VALUES ($1, $2, $3, $4, $5, $6, FALSE)`,\n    [v4(), params.body, params.userId, params.agentId, params.roomId, params.type],\n  );\n}\n\nexport async function logMemorySqlite(\n  db: any,\n  params: {\n    userId: UUID;\n    agentId: UUID;\n    roomId: UUID;\n    type: string;\n    body: string;\n  },\n): Promise<void> {\n  const sql = `\n            INSERT INTO logs (id, userId, agentId, roomId, type, body, isSynced)\n            VALUES (?, ?, ?, ?, ?, ?, 0)\n        `;\n  db.prepare(sql).run(v4(), params.userId, params.agentId, params.roomId, params.type, params.body);\n}\n\nexport async function getUnsyncedLogsPostgres(db: any): Promise<\n  {\n    id: UUID;\n    body: string;\n    userId: UUID;\n    agentId: UUID | null;\n    roomId: UUID;\n    type: string;\n    createdAt: Date;\n  }[]\n> {\n  const { rows } = await db.query(\n    `SELECT id, body, \"userId\", \"agentId\", \"roomId\", type, \"createdAt\"\n         FROM logs WHERE \"isSynced\" = FALSE\n         ORDER BY \"createdAt\" ASC\n         LIMIT 100`,\n  );\n\n  return rows.map((row) => ({\n    ...row,\n    body: typeof row.body === 'string' ? row.body : JSON.stringify(row.body),\n  }));\n}\n\nexport async function markLogsAsSyncedPostgres(db: any, logIds: UUID[]): Promise<void> {\n  if (logIds.length === 0) {\n    elizaLogger.warn('‚ö† No log IDs provided for marking as synced.');\n    return;\n  }\n\n  elizaLogger.info(`‚úÖ Marking logs as synced: ${JSON.stringify(logIds)}`);\n\n  const placeholders = logIds.map((_, i) => `$${i + 1}`).join(', ');\n  try {\n    await db.query(`UPDATE logs SET \"isSynced\" = TRUE WHERE id IN (${placeholders})`, logIds);\n    elizaLogger.info(`‚úÖ Successfully marked ${logIds.length} logs as synced.`);\n  } catch (error) {\n    elizaLogger.error(`‚ùå Failed to mark logs as synced: ${error.message}`, {\n      logIds,\n      error: error instanceof Error ? error.message : String(error),\n    });\n  }\n}\n\nexport async function getUnsyncedLogsSqlite(db: any): Promise<{ id: UUID; body: string }[]> {\n  const sql = 'SELECT id, type, body FROM logs WHERE isSynced = 0 ORDER BY createdAt ASC';\n  return db.prepare(sql).all() as { id: UUID; body: string }[];\n}\n\nexport async function markLogsAsSyncedSqlite(db: any, logIds: UUID[]): Promise<void> {\n  if (logIds.length === 0) return;\n  const placeholders = logIds.map(() => '?').join(', ');\n  const sql = `UPDATE logs SET isSynced = 1 WHERE id IN (${placeholders})`;\n  db.prepare(sql).run(...logIds);\n}\n","import crypto from 'crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","import {\n  type Action,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  type ActionExample,\n  elizaLogger,\n  ServiceType,\n} from '@elizaos/core';\nimport { RecallService } from '../services/recall.service';\n\nconst keywords = ['buy', 'credit', 'credits', 'purchase', 'add credit', 'add credits'];\n\nexport const buyCreditAction: Action = {\n  name: 'BUY_CREDIT',\n  similes: [\n    'BUY_CREDIT',\n    'buy credit',\n    'buy credits',\n    'purchase credit',\n    'purchase credits',\n    'add credit',\n    'add credits',\n    'ADD_CREDIT',\n    'RELOAD_CREDIT',\n    'PURCHASE_CREDIT',\n    'BUY RECALL CREDITS',\n    'GET MORE CREDITS',\n    'RECHARGE ACCOUNT',\n  ],\n  validate: async (_runtime: IAgentRuntime, message: Memory) => {\n    const text = message.content.text.toLowerCase();\n    const amountMatch = text.match(/([\\d.]+)/);\n\n    if (!amountMatch) {\n      return false;\n    }\n\n    const amount = parseFloat(amountMatch[1]);\n    if (isNaN(amount) || amount <= 0) {\n      return false;\n    }\n\n    // Now check for any matching keywords\n    if (!keywords.some((keyword) => text.includes(keyword))) {\n      elizaLogger.error('BUY_CREDIT failed: No valid keyword found in message.');\n      return false;\n    }\n\n    elizaLogger.info(`BUY_CREDIT Validation Passed! Amount: ${amount}`);\n    return true;\n  },\n  description: \"Buys Recall credits for the agent's wallet\",\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n    _options: { [key: string]: unknown },\n    callback?: HandlerCallback,\n  ): Promise<boolean> => {\n    const recallService = runtime.services.get('recall' as ServiceType) as RecallService;\n    let text = '';\n\n    try {\n      let currentState = state;\n      if (!currentState) {\n        currentState = (await runtime.composeState(message)) as State;\n      } else {\n        currentState = await runtime.updateRecentMessageState(currentState);\n      }\n      elizaLogger.info(`BUY_CREDIT Handler: ${message.content.text}`);\n      const amountMatch = message.content.text.trim().match(/([\\d.]+)/);\n\n      if (!amountMatch) {\n        text = '‚ùå Invalid credit request. Please specify an amount.';\n        elizaLogger.error('BUY_CREDIT failed: No amount provided.');\n      } else {\n        const amount = parseFloat(amountMatch[1]);\n        if (isNaN(amount) || amount <= 0) {\n          text = '‚ùå Invalid credit amount. Please enter a number greater than 0.';\n          elizaLogger.error('BUY_CREDIT failed: Invalid amount.');\n        } else {\n          elizaLogger.info(`Attempting to purchase ${amount} credits...`);\n\n          // Call RecallService to buy credit\n          const result = await recallService.buyCredit(amount.toString());\n\n          if (result?.meta?.tx) {\n            // Check for transaction receipt instead of direct result\n            text = `‚úÖ Successfully purchased ${amount} Recall credits! Transaction hash: ${result.meta.tx.transactionHash}`;\n            elizaLogger.info(\n              `BUY_CREDIT success: ${amount} credits added. TX: ${result.meta.tx.transactionHash}`,\n            );\n          } else {\n            text = '‚ùå Credit purchase failed. Please try again later.';\n            elizaLogger.error('BUY_CREDIT failed: Transaction unsuccessful');\n          }\n        }\n      }\n    } catch (error) {\n      text = '‚ö†Ô∏è An error occurred while purchasing credits. Please try again later.';\n      elizaLogger.error(`BUY_CREDIT error: ${error.message}`);\n    }\n\n    // Create a new memory entry for the response\n    const newMemory: Memory = {\n      ...message,\n      userId: message.agentId,\n      content: {\n        text,\n        action: 'BUY_CREDIT',\n        source: message.content.source,\n      },\n    };\n\n    // Save to memory\n    await runtime.messageManager.createMemory(newMemory);\n\n    // Call callback AFTER saving memory\n    await callback?.({\n      text,\n    });\n\n    return true;\n  },\n  examples: [\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Please buy 0.1 credits for my account' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: '‚úÖ Successfully purchased 0.1 Recall credits! Transaction hash: 0x...',\n          action: 'BUY_CREDIT',\n        },\n      },\n    ],\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Please buy 1.5 credits for my account' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: '‚úÖ Successfully bought 1.5 Recall credits! Transaction hash: 0x...',\n          action: 'BUY_CREDIT',\n        },\n      },\n    ],\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Please add 3 credits to my account' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: '‚úÖ Successfully added 3 Recall credits to your account! Transaction hash: 0x...',\n          action: 'BUY_CREDIT',\n        },\n      },\n    ],\n  ] as ActionExample[][],\n};\n","import {\n  type Action,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  type ActionExample,\n  elizaLogger,\n  ServiceType,\n} from '@elizaos/core';\nimport { RecallService } from '../services/recall.service';\n\nconst balanceKeywords = [\n  'balance',\n  'credit balance',\n  'account balance',\n  'how many credits',\n  'check my credits',\n  'my available credits',\n  'how much credit',\n  'how much do I have',\n  'do I have credits',\n];\n\nexport const getCreditBalanceAction: Action = {\n  name: 'GET_CREDIT_BALANCE',\n  similes: [\n    'GET_CREDIT_BALANCE',\n    'CHECK_CREDIT',\n    'ACCOUNT_CREDIT_BALANCE',\n    'CREDIT_BALANCE',\n    'BALANCE_CHECK',\n    'AVAILABLE_CREDITS',\n  ],\n  validate: async (_runtime: IAgentRuntime, message: Memory) => {\n    const text = message.content.text.toLowerCase();\n\n    // Ensure the user is asking about balance, not trying to buy credits\n    if (!balanceKeywords.some((keyword) => text.includes(keyword))) {\n      return false;\n    }\n\n    // Ensure there are NO numeric values (to prevent confusion with BUY_CREDIT)\n    const amountMatch = text.match(/([\\d.]+)/);\n    if (amountMatch) {\n      elizaLogger.error(\n        'GET_CREDIT_BALANCE validation failed: Message contains numeric values (possible buy request).',\n      );\n      return false;\n    }\n\n    elizaLogger.info('GET_CREDIT_BALANCE Validation Passed!');\n    return true;\n  },\n  description: \"Checks the user's Recall credit balance\",\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n    _options: { [key: string]: unknown },\n    callback?: HandlerCallback,\n  ): Promise<boolean> => {\n    const recallService = runtime.services.get('recall' as ServiceType) as RecallService;\n    let text = '';\n\n    try {\n      let currentState = state;\n      if (!currentState) {\n        currentState = (await runtime.composeState(message)) as State;\n      } else {\n        currentState = await runtime.updateRecentMessageState(currentState);\n      }\n      elizaLogger.info('Fetching credit balance...');\n      const balanceInfo = await recallService.getCreditInfo();\n\n      if (balanceInfo?.creditFree !== undefined) {\n        const balance = balanceInfo.creditFree.toString(); // Ensure it's a string\n        elizaLogger.info(`Credit Balance Retrieved: ${balance}`);\n\n        text = `üí∞ Your current Recall credit balance is **${balance} credits**.`;\n      } else {\n        elizaLogger.error('GET_CREDIT_BALANCE failed: No balance info received.');\n        text = '‚ö†Ô∏è Unable to retrieve your credit balance. Please try again later.';\n      }\n    } catch (error) {\n      elizaLogger.error(`GET_CREDIT_BALANCE error: ${error.message}`);\n      text = '‚ö†Ô∏è An error occurred while fetching your credit balance. Please try again later.';\n    }\n\n    // Create a new memory entry for the response\n    const newMemory: Memory = {\n      ...message,\n      userId: message.agentId,\n      content: {\n        text,\n        action: 'GET_CREDIT_BALANCE',\n        source: message.content.source,\n      },\n    };\n\n    // Save to memory\n    await runtime.messageManager.createMemory(newMemory);\n\n    // Call callback AFTER saving memory\n    await callback?.({\n      text,\n    });\n\n    return true;\n  },\n  examples: [\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'What is my account credit balance?' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: 'üí∞ Your current Recall credit balance is **X credits**.',\n          action: 'GET_CREDIT_BALANCE',\n        },\n      },\n    ],\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'How many credits are in my account?' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: 'üí∞ Your current Recall credit balance is **X credits**.',\n          action: 'GET_CREDIT_BALANCE',\n        },\n      },\n    ],\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Can you check my available credits?' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: 'üí∞ Your current Recall credit balance is **X credits**.',\n          action: 'GET_CREDIT_BALANCE',\n        },\n      },\n    ],\n  ] as ActionExample[][],\n};\n","import {\n  type Action,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  type ActionExample,\n  elizaLogger,\n  ServiceType,\n} from '@elizaos/core';\nimport { RecallService } from '../services/recall.service';\n\nconst accountInfoKeywords = [\n  'account data',\n  'account info',\n  'check my account',\n  'get my account',\n  'account details',\n  'retrieve account',\n  \"what's my account\",\n];\n\nexport const getAccountInfoAction: Action = {\n  name: 'GET_ACCOUNT_INFO',\n  similes: [\n    'GET_ACCOUNT_INFO',\n    'CHECK_ACCOUNT',\n    'ACCOUNT_INFORMATION',\n    'ACCOUNT_DETAILS',\n    'RETRIEVE_ACCOUNT_INFO',\n  ],\n  validate: async (_runtime: IAgentRuntime, message: Memory) => {\n    const text = message.content.text.toLowerCase();\n\n    // Ensure the user is specifically requesting account info\n    if (!accountInfoKeywords.some((keyword) => text.includes(keyword))) {\n      return false;\n    }\n\n    elizaLogger.info('GET_ACCOUNT_INFO Validation Passed!');\n    return true;\n  },\n  description: \"Retrieves the user's Recall account information.\",\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n    _options: { [key: string]: unknown },\n    callback?: HandlerCallback,\n  ): Promise<boolean> => {\n    const recallService = runtime.services.get('recall' as ServiceType) as RecallService;\n    let text = '';\n\n    try {\n      let currentState = state;\n      if (!currentState) {\n        currentState = (await runtime.composeState(message)) as State;\n      } else {\n        currentState = await runtime.updateRecentMessageState(currentState);\n      }\n      elizaLogger.info('Fetching account information...');\n      const accountInfo = await recallService.getAccountInfo();\n\n      if (accountInfo) {\n        const { address, nonce, balance, parentBalance } = accountInfo;\n        const formattedBalance =\n          balance !== undefined ? `${balance.toString()} credits` : 'Unknown';\n        const formattedParentBalance =\n          parentBalance !== undefined ? `${parentBalance.toString()} credits` : 'N/A';\n\n        elizaLogger.info(\n          `Account Info Retrieved: Address: ${address}, Balance: ${formattedBalance}`,\n        );\n\n        text = `üìú **Your Recall Account Information:**\\n\\nüîπ **Address:** ${address}\\nüîπ **Nonce:** ${nonce}\\nüîπ **Balance:** ${formattedBalance}\\nüîπ **Parent Balance:** ${formattedParentBalance}`;\n      } else {\n        elizaLogger.error('GET_ACCOUNT_INFO failed: No account info received.');\n        text = '‚ö†Ô∏è Unable to retrieve your account information. Please try again later.';\n      }\n    } catch (error) {\n      elizaLogger.error(`GET_ACCOUNT_INFO error: ${error.message}`);\n      text =\n        '‚ö†Ô∏è An error occurred while fetching your account information. Please try again later.';\n    }\n\n    // Create a new memory entry for the response\n    const newMemory: Memory = {\n      ...message,\n      userId: message.agentId,\n      content: {\n        text,\n        action: 'GET_ACCOUNT_INFO',\n        source: message.content.source,\n      },\n    };\n\n    // Save to memory\n    await runtime.messageManager.createMemory(newMemory);\n\n    // Call callback AFTER saving memory\n    await callback?.({\n      text,\n    });\n\n    return true;\n  },\n  examples: [\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Check my account data' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: 'üìú **Your Recall Account Information:**\\nüîπ **Address:** 0x123...456\\nüîπ **Nonce:** 5\\nüîπ **Balance:** 100 credits\\nüîπ **Parent Balance:** 500 credits',\n          action: 'GET_ACCOUNT_INFO',\n        },\n      },\n    ],\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Get my account information' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: 'üìú **Your Recall Account Information:**\\nüîπ **Address:** 0xABC...DEF\\nüîπ **Nonce:** 3\\nüîπ **Balance:** 200 credits\\nüîπ **Parent Balance:** N/A',\n          action: 'GET_ACCOUNT_INFO',\n        },\n      },\n    ],\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Retrieve my account details' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: 'üìú **Your Recall Account Information:**\\nüîπ **Address:** 0x789...XYZ\\nüîπ **Nonce:** 2\\nüîπ **Balance:** 50 credits\\nüîπ **Parent Balance:** 300 credits',\n          action: 'GET_ACCOUNT_INFO',\n        },\n      },\n    ],\n  ] as ActionExample[][],\n};\n","import {\n  type Action,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  type ActionExample,\n  elizaLogger,\n  ServiceType,\n} from '@elizaos/core';\nimport { RecallService } from '../services/recall.service';\n\nconst bucketKeywords = [\n  'list buckets',\n  'get my buckets',\n  'retrieve my buckets',\n  'show my buckets',\n  'fetch my buckets',\n  'available buckets',\n];\n\nexport const listBucketsAction: Action = {\n  name: 'LIST_BUCKETS',\n  similes: ['LIST_BUCKETS', 'GET_BUCKETS', 'SHOW_BUCKETS', 'FETCH_BUCKETS', 'AVAILABLE_BUCKETS'],\n  validate: async (_runtime: IAgentRuntime, message: Memory) => {\n    const text = message.content.text.toLowerCase();\n\n    // Ensure the user is requesting a list of buckets\n    if (!bucketKeywords.some((keyword) => text.includes(keyword))) {\n      return false;\n    }\n\n    elizaLogger.info('LIST_BUCKETS Validation Passed!');\n    return true;\n  },\n  description: 'Retrieves and lists all available Recall buckets.',\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n    _options: { [key: string]: unknown },\n    callback?: HandlerCallback,\n  ): Promise<boolean> => {\n    const recallService = runtime.services.get('recall' as ServiceType) as RecallService;\n    let text = '';\n\n    try {\n      let currentState = state;\n      if (!currentState) {\n        currentState = (await runtime.composeState(message)) as State;\n      } else {\n        currentState = await runtime.updateRecentMessageState(currentState);\n      }\n\n      elizaLogger.info('Fetching bucket list...');\n      const bucketList = await recallService.listBuckets();\n\n      if (bucketList && bucketList.length > 0) {\n        const bucketDetails = bucketList\n          .map((bucket) => `üîπ **${bucket.kind}** (Address: ${bucket.addr})`)\n          .join('\\n');\n\n        text = `üìÇ **Your Recall Buckets:**\\n\\n${bucketDetails}`;\n        elizaLogger.info(`LIST_BUCKETS success: Retrieved ${bucketList.length} buckets.`);\n      } else {\n        text = 'üìÇ You currently have no Recall buckets.';\n        elizaLogger.info('LIST_BUCKETS success: No buckets found.');\n      }\n    } catch (error) {\n      text = '‚ö†Ô∏è An error occurred while retrieving your buckets. Please try again later.';\n      elizaLogger.error(`LIST_BUCKETS error: ${error.message}`);\n    }\n\n    // Create a new memory entry for the response\n    const newMemory: Memory = {\n      ...message,\n      userId: message.agentId,\n      content: {\n        text,\n        action: 'LIST_BUCKETS',\n        source: message.content.source,\n      },\n    };\n\n    // Save to memory\n    await runtime.messageManager.createMemory(newMemory);\n\n    // Call callback AFTER saving memory\n    await callback?.({ text });\n\n    return true;\n  },\n  examples: [\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Get a list of my buckets' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: 'üìÇ **Your Recall Buckets:**\\nüîπ **Bucket Type 1** (Address: 0x123...456)\\nüîπ **Bucket Type 2** (Address: 0x789...ABC)',\n          action: 'LIST_BUCKETS',\n        },\n      },\n    ],\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Show me my buckets' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: 'üìÇ **Your Recall Buckets:**\\nüîπ **Data Storage** (Address: 0xDEF...789)\\nüîπ **AI Memory** (Address: 0x123...ABC)',\n          action: 'LIST_BUCKETS',\n        },\n      },\n    ],\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Do I have any buckets?' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: 'üìÇ You currently have no Recall buckets.',\n          action: 'LIST_BUCKETS',\n        },\n      },\n    ],\n  ] as ActionExample[][],\n};\n","import {\n  type Action,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  type ActionExample,\n  elizaLogger,\n  ServiceType,\n} from '@elizaos/core';\nimport { RecallService } from '../services/recall.service';\n\nconst createBucketKeywords = [\n  'create a bucket',\n  'make a bucket',\n  'new bucket',\n  'generate a bucket',\n  'add a bucket',\n];\n\nexport const createBucketAction: Action = {\n  name: 'CREATE_BUCKET',\n  similes: ['CREATE_BUCKET', 'MAKE_BUCKET', 'NEW_BUCKET', 'GENERATE_BUCKET', 'ADD_BUCKET'],\n  validate: async (_runtime: IAgentRuntime, message: Memory) => {\n    const text = message.content.text.toLowerCase();\n\n    // Ensure the message contains a create bucket request\n    if (!createBucketKeywords.some((keyword) => text.includes(keyword))) {\n      return false;\n    }\n\n    // Extract alias from quoted text (single or double quotes)\n    const aliasMatch = message.content.text.match(/[\"']([^\"']+)[\"']/);\n    if (!aliasMatch || !aliasMatch[1]) {\n      elizaLogger.error('CREATE_BUCKET validation failed: No alias detected in quotes.');\n      return false;\n    }\n\n    elizaLogger.info(`CREATE_BUCKET Validation Passed! Alias: ${aliasMatch[1]}`);\n    return true;\n  },\n  description: 'Creates a new Recall bucket with a given alias.',\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n    _options: { [key: string]: unknown },\n    callback?: HandlerCallback,\n  ): Promise<boolean> => {\n    const recallService = runtime.services.get('recall' as ServiceType) as RecallService;\n    let text = '';\n\n    try {\n      let currentState = state;\n      if (!currentState) {\n        currentState = (await runtime.composeState(message)) as State;\n      } else {\n        currentState = await runtime.updateRecentMessageState(currentState);\n      }\n\n      elizaLogger.info(`CREATE_BUCKET Handler triggered: ${message.content.text}`);\n\n      // Extract alias from quoted text\n      const aliasMatch = message.content.text.match(/[\"']([^\"']+)[\"']/);\n      if (!aliasMatch || !aliasMatch[1]) {\n        text = '‚ùå Invalid bucket request. Please specify an alias in quotes.';\n        elizaLogger.error('CREATE_BUCKET failed: No alias found.');\n      } else {\n        const bucketAlias = aliasMatch[1].trim();\n        elizaLogger.info(`Creating bucket with alias: ${bucketAlias}`);\n\n        // Call RecallService to create or fetch bucket\n        const bucketAddress = await recallService.getOrCreateBucket(bucketAlias);\n\n        if (bucketAddress) {\n          text = `‚úÖ Successfully created or retrieved bucket **\"${bucketAlias}\"** at address: **${bucketAddress}**`;\n          elizaLogger.info(\n            `CREATE_BUCKET success: Bucket \"${bucketAlias}\" created at ${bucketAddress}`,\n          );\n        } else {\n          text = '‚ùå Bucket creation failed. Please try again later.';\n          elizaLogger.error('CREATE_BUCKET failed: No response from RecallService.');\n        }\n      }\n    } catch (error) {\n      text = '‚ö†Ô∏è An error occurred while creating your bucket. Please try again later.';\n      elizaLogger.error(`CREATE_BUCKET error: ${error.message}`);\n    }\n\n    // Create a new memory entry for the response\n    const newMemory: Memory = {\n      ...message,\n      userId: message.agentId,\n      content: {\n        text,\n        action: 'CREATE_BUCKET',\n        source: message.content.source,\n      },\n    };\n\n    // Save to memory\n    await runtime.messageManager.createMemory(newMemory);\n\n    // Call callback AFTER saving memory\n    await callback?.({ text });\n\n    return true;\n  },\n  examples: [\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Create a bucket for me named \"new-bucket\"' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: '‚úÖ Successfully created or retrieved bucket **\"new-bucket\"** at address: **0x123...456**',\n          action: 'CREATE_BUCKET',\n        },\n      },\n    ],\n    [\n      {\n        user: '{{user1}}',\n        content: { text: \"Make a bucket for me with the alias 'backup-data'\" },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: '‚úÖ Successfully created or retrieved bucket **\"backup-data\"** at address: **0xDEF...789**',\n          action: 'CREATE_BUCKET',\n        },\n      },\n    ],\n    [\n      {\n        user: '{{user1}}',\n        content: { text: \"Generate a new bucket called 'logs'\" },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: '‚úÖ Successfully created or retrieved bucket **\"logs\"** at address: **0xAAA...BBB**',\n          action: 'CREATE_BUCKET',\n        },\n      },\n    ],\n  ] as ActionExample[][],\n};\n","import {\n  type Action,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  type ActionExample,\n  elizaLogger,\n  ServiceType,\n} from '@elizaos/core';\nimport { RecallService } from '../services/recall.service';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nconst addObjectKeywords = ['add object', 'store object', 'upload object', 'save object'];\n\nexport const addObjectAction: Action = {\n  name: 'ADD_OBJECT',\n  similes: ['ADD_OBJECT', 'STORE_OBJECT', 'UPLOAD_OBJECT', 'SAVE_OBJECT', 'ADD_TO_BUCKET'],\n\n  validate: async (_runtime: IAgentRuntime, message: Memory) => {\n    const text = message.content.text.toLowerCase();\n\n    // Ensure message contains an add object request\n    if (!addObjectKeywords.some((keyword) => text.includes(keyword))) {\n      return false;\n    }\n\n    // Extract first and second quoted strings\n    const matches = message.content.text.match(/\"([^\"]+)\"\\s+.*?\"([^\"]+)\"/);\n    if (!matches || matches.length < 3) {\n      elizaLogger.error(\n        'ADD_OBJECT validation failed: No valid object path and bucket alias detected.',\n      );\n      return false;\n    }\n\n    elizaLogger.info(\n      `ADD_OBJECT Validation Passed! Object: ${matches[1]}, Bucket Alias: ${matches[2]}`,\n    );\n    return true;\n  },\n\n  description: 'Adds an object to a specified Recall bucket.',\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n    _options: { [key: string]: unknown },\n    callback?: HandlerCallback,\n  ): Promise<boolean> => {\n    const recallService = runtime.services.get('recall' as ServiceType) as RecallService;\n    let text = '';\n\n    try {\n      let currentState = state;\n      if (!currentState) {\n        currentState = (await runtime.composeState(message)) as State;\n      } else {\n        currentState = await runtime.updateRecentMessageState(currentState);\n      }\n\n      elizaLogger.info(`ADD_OBJECT Handler triggered: ${message.content.text}`);\n\n      // Extract object file and bucket alias\n      const matches = message.content.text.match(/\"([^\"]+)\"\\s+.*?\"([^\"]+)\"/);\n      if (!matches || matches.length < 3) {\n        text =\n          '‚ùå Invalid request. Please specify both the object file and the bucket alias in double quotes.';\n        elizaLogger.error('ADD_OBJECT failed: Missing object or bucket alias.');\n      } else {\n        const objectPath = matches[1].trim();\n        const bucketAlias = matches[2].trim();\n\n        elizaLogger.info(`Looking up bucket for alias: ${bucketAlias}`);\n\n        // Retrieve or create the bucket\n        const bucketAddress = await recallService.getOrCreateBucket(bucketAlias);\n        if (!bucketAddress) {\n          text = `‚ùå Failed to find or create bucket with alias \"${bucketAlias}\".`;\n          elizaLogger.error(`ADD_OBJECT failed: No bucket found for alias \"${bucketAlias}\".`);\n        } else {\n          elizaLogger.info(`Found bucket ${bucketAddress} for alias \"${bucketAlias}\".`);\n\n          // Resolve absolute path and check if file exists\n          const filePath = path.resolve(process.cwd(), objectPath);\n          if (!fs.existsSync(filePath)) {\n            text = `‚ùå Object file not found: ${objectPath}`;\n            elizaLogger.error(`ADD_OBJECT failed: File \"${filePath}\" does not exist.`);\n          } else {\n            // Read file data\n            const fileData = fs.readFileSync(filePath);\n            const fileName = path.basename(filePath);\n\n            elizaLogger.info(`Uploading object \"${fileName}\" to bucket \"${bucketAlias}\"...`);\n\n            // Call RecallService to add object\n            const result = await recallService.addObject(\n              bucketAddress,\n              fileName,\n              fileData as unknown as File,\n            );\n\n            if (result?.meta?.tx) {\n              // Check for transaction receipt instead of just result\n              text = `‚úÖ Successfully added object **\"${fileName}\"** to bucket **\"${bucketAlias}\"**. Transaction hash: ${result.meta.tx.transactionHash}`;\n              elizaLogger.info(\n                `ADD_OBJECT success: \"${fileName}\" added to bucket \"${bucketAlias}\". TX: ${result.meta.tx.transactionHash}`,\n              );\n            } else {\n              text = '‚ùå Failed to add object to the bucket. Please try again later.';\n              elizaLogger.error('ADD_OBJECT failed: Transaction unsuccessful');\n            }\n          }\n        }\n      }\n    } catch (error) {\n      text = '‚ö†Ô∏è An error occurred while adding the object. Please try again later.';\n      elizaLogger.error(`ADD_OBJECT error: ${error.message}`);\n      if (error.cause) {\n        elizaLogger.error(`ADD_OBJECT error cause: ${error.cause.message}`);\n      }\n    }\n\n    // Create a new memory entry for the response\n    const newMemory: Memory = {\n      ...message,\n      userId: message.agentId,\n      content: {\n        text,\n        action: 'ADD_OBJECT',\n        source: message.content.source,\n      },\n    };\n\n    // Save to memory\n    await runtime.messageManager.createMemory(newMemory);\n\n    // Call callback AFTER saving memory\n    await callback?.({ text });\n\n    return true;\n  },\n\n  examples: [\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Add object \"./object.txt\" to \"my-bucket\"' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: '‚úÖ Successfully added object **\"object.txt\"** to bucket **\"my-bucket\"**. Transaction hash: 0x...',\n          action: 'ADD_OBJECT',\n        },\n      },\n    ],\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Store object \"./data.json\" in \"backup\"' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: '‚úÖ Successfully added object **\"data.json\"** to bucket **\"backup\"**. Transaction hash: 0x...',\n          action: 'ADD_OBJECT',\n        },\n      },\n    ],\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Upload \"./logs.txt\" into \"logs\"' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: '‚úÖ Successfully added object **\"logs.txt\"** to bucket **\"logs\"**. Transaction hash: 0x...',\n          action: 'ADD_OBJECT',\n        },\n      },\n    ],\n  ] as ActionExample[][],\n};\n","import {\n  type Action,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  type ActionExample,\n  elizaLogger,\n  ServiceType,\n} from '@elizaos/core';\nimport { RecallService } from '../services/recall.service';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nconst getObjectKeywords = ['get object', 'retrieve object', 'fetch object', 'download object'];\n\nexport const getObjectAction: Action = {\n  name: 'GET_OBJECT',\n  similes: ['GET_OBJECT', 'RETRIEVE_OBJECT', 'FETCH_OBJECT', 'DOWNLOAD_OBJECT', 'GET_FROM_BUCKET'],\n  validate: async (_runtime: IAgentRuntime, message: Memory) => {\n    const text = message.content.text.toLowerCase();\n\n    // Ensure message contains a valid \"get object\" request\n    if (!getObjectKeywords.some((keyword) => text.includes(keyword))) {\n      return false;\n    }\n\n    // Extract object key and bucket alias (both wrapped in double quotes)\n    const matches = message.content.text.match(/\"([^\"]+)\"\\s+from bucket\\s+\"([^\"]+)\"/);\n    if (!matches || matches.length < 3) {\n      elizaLogger.error(\n        'GET_OBJECT validation failed: No valid object key and bucket alias detected.',\n      );\n      return false;\n    }\n\n    elizaLogger.info(\n      `GET_OBJECT Validation Passed! Object: ${matches[1]}, Bucket Alias: ${matches[2]}`,\n    );\n    return true;\n  },\n  description: 'Retrieves an object from a specified Recall bucket.',\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State,\n    _options: { [key: string]: unknown },\n    callback?: HandlerCallback,\n  ): Promise<boolean> => {\n    const recallService = runtime.services.get('recall' as ServiceType) as RecallService;\n    let text = '';\n\n    try {\n      let currentState = state;\n      if (!currentState) {\n        currentState = (await runtime.composeState(message)) as State;\n      } else {\n        currentState = await runtime.updateRecentMessageState(currentState);\n      }\n\n      elizaLogger.info(`GET_OBJECT Handler triggered: ${message.content.text}`);\n\n      // Extract object key and bucket alias\n      const matches = message.content.text.match(/\"([^\"]+)\"\\s+from bucket\\s+\"([^\"]+)\"/);\n      if (!matches || matches.length < 3) {\n        text =\n          '‚ùå Invalid request. Please specify both the object key and the bucket alias in double quotes.';\n        elizaLogger.error('GET_OBJECT failed: Missing object key or bucket alias.');\n      } else {\n        const objectKey = matches[1].trim();\n        const bucketAlias = matches[2].trim();\n\n        elizaLogger.info(`Looking up bucket for alias: ${bucketAlias}`);\n\n        // Retrieve the bucket address\n        const bucketAddress = await recallService.getOrCreateBucket(bucketAlias);\n        if (!bucketAddress) {\n          text = `‚ùå Failed to find or create bucket with alias \"${bucketAlias}\".`;\n          elizaLogger.error(`GET_OBJECT failed: No bucket found for alias \"${bucketAlias}\".`);\n        } else {\n          elizaLogger.info(`Found bucket ${bucketAddress} for alias \"${bucketAlias}\".`);\n\n          // Ensure the downloads directory exists\n          const downloadsDir = path.resolve(process.cwd(), 'downloads');\n          if (!fs.existsSync(downloadsDir)) {\n            fs.mkdirSync(downloadsDir, { recursive: true });\n          }\n\n          // Retrieve the object from Recall\n          const objectData = await recallService.getObject(bucketAddress, objectKey);\n\n          if (objectData) {\n            // Define the file path within the downloads directory\n            const filePath = path.join(downloadsDir, objectKey);\n\n            // Write the file to the downloads directory\n            fs.writeFileSync(filePath, Buffer.from(objectData));\n\n            text = `‚úÖ Successfully retrieved object **\"${objectKey}\"** from bucket **\"${bucketAlias}\"**.\\nüìÇ File saved at: \\`${filePath}\\``;\n            elizaLogger.info(\n              `GET_OBJECT success: \"${objectKey}\" retrieved and saved to \"${filePath}\".`,\n            );\n          } else {\n            text = `‚ùå Object **\"${objectKey}\"** not found in bucket **\"${bucketAlias}\"**.`;\n            elizaLogger.error(`GET_OBJECT failed: Object \"${objectKey}\" not found.`);\n          }\n        }\n      }\n    } catch (error) {\n      text = '‚ö†Ô∏è An error occurred while retrieving the object. Please try again later.';\n      elizaLogger.error(`GET_OBJECT error: ${error.message}`);\n    }\n\n    // Create a new memory entry for the response\n    const newMemory: Memory = {\n      ...message,\n      userId: message.agentId,\n      content: {\n        text,\n        action: 'GET_OBJECT',\n        source: message.content.source,\n      },\n    };\n\n    // Save to memory\n    await runtime.messageManager.createMemory(newMemory);\n\n    // Call callback AFTER saving memory\n    await callback?.({ text });\n\n    return true;\n  },\n  examples: [\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Get object \"object.txt\" from bucket \"my-bucket\"' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: '‚úÖ Successfully retrieved object **\"object.txt\"** from bucket **\"my-bucket\"**.\\nüìÇ File saved at: `/path/to/object.txt`',\n          action: 'GET_OBJECT',\n        },\n      },\n    ],\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Retrieve object \"data.json\" from bucket \"backup\"' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: '‚úÖ Successfully retrieved object **\"data.json\"** from bucket **\"backup\"**.\\nüìÇ File saved at: `/path/to/data.json`',\n          action: 'GET_OBJECT',\n        },\n      },\n    ],\n    [\n      {\n        user: '{{user1}}',\n        content: { text: 'Fetch object \"logs.txt\" from bucket \"logs\"' },\n      },\n      {\n        user: '{{agentName}}',\n        content: {\n          text: '‚úÖ Successfully retrieved object **\"logs.txt\"** from bucket **\"logs\"**.\\nüìÇ File saved at: `/path/to/logs.txt`',\n          action: 'GET_OBJECT',\n        },\n      },\n    ],\n  ] as ActionExample[][],\n};\n","import {\n  IAgentRuntime,\n  Memory,\n  Provider,\n  State,\n  elizaLogger,\n  messageCompletionFooter,\n  ModelClass,\n  composeContext,\n  generateText,\n} from '@elizaos/core';\nimport { logMemoryPostgres, logMemorySqlite } from '../utils.ts';\n\nexport const systemPrompt = `You are an AI assistant helping with a conversation.\nBefore answering, please explicitly write out your step-by-step reasoning process starting with \"REASONING:\" and ending with \"ANSWER:\".\nAlways include both sections, even for simple questions.`;\n\nexport const messageHandlerTemplate = `# Action Examples\n{{actionExamples}}\n(Action examples are for reference only. Do not use the information from them in your response.)\n\n# Knowledge\n{{knowledge}}\n\n# Task: Generate a detailed response and actions for the character {{agentName}}.\nAbout {{agentName}}:\n{{bio}}\n{{lore}}\n\n{{providers}}\n\n{{attachments}}\n\n# Capabilities\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\n\n{{messageDirections}}\n\n{{recentMessages}}\n\n{{actions}}\n\n# Instructions: Think step-by-step before responding.\n\nPlease follow these steps in your reasoning:\n1. Identify the key elements in the conversation, including any knowledge and recent messages.\n2. Break down the problem into smaller logical steps.\n3. Analyze the relevant details, context, and past interactions.\n4. Formulate a preliminary response that addresses the requirements.\n5. If the user's message aligns with any actions you can take, consider which is most appropriate.\n\n## Formatting Requirements\n\nYour response MUST have two parts:\n\nREASONING:\n(Write your step-by-step analysis here)\n\nANSWER:\n(Provide your final answer in the JSON format below)\n\n# Response format should be formatted in a valid JSON block like this:\n\\`\\`\\`json\n{ \"user\": \"{{agentName}}\", \"text\": \"<string>\", \"action\": \"<string>\" }\n\\`\\`\\`\n\nThe \"action\" field should be one of the options in [Available Actions] and the \"text\" field should be the response you want to send.\n`;\n\n/**\n * Extracts the chain of thought text from the model response.\n * Focuses on REASONING/ANSWER format and implements fallbacks.\n * @param text The model response text\n * @returns The extracted chain of thought text\n */\nfunction extractChainOfThought(text: string): string {\n  // Primary approach: Look for \"REASONING:\" section\n  const reasoningMatch = text.match(/REASONING:\\s*([\\s\\S]*?)(?=ANSWER:|$)/i);\n  if (reasoningMatch && reasoningMatch[1]) {\n    const reasoning = reasoningMatch[1].trim();\n    if (reasoning.length > 0) {\n      elizaLogger.info(`[extractChainOfThought] Successfully extracted REASONING section`);\n      return reasoning;\n    }\n  }\n\n  // Fallback 1: Look for text before the ANSWER section\n  const answerMatch = text.match(/ANSWER:/i);\n  if (answerMatch) {\n    const answerIndex = text.indexOf(answerMatch[0]);\n    if (answerIndex > 20) {\n      const beforeAnswer = text.substring(0, answerIndex).trim();\n      elizaLogger.info(`[extractChainOfThought] Extracted everything before ANSWER marker`);\n      return beforeAnswer;\n    }\n  }\n\n  // Fallback 2: Look for text before JSON\n  const jsonMatch = text.match(/```json/i);\n  if (jsonMatch) {\n    const jsonIndex = text.indexOf(jsonMatch[0]);\n    if (jsonIndex > 20) {\n      // Ensure there's enough text before the JSON\n      const beforeJson = text.substring(0, jsonIndex).trim();\n      elizaLogger.info(`[extractChainOfThought] Extracted text before JSON formatting`);\n      return beforeJson;\n    }\n  }\n\n  // Last resort: If we couldn't extract anything, log a warning and take the first part of the text\n  elizaLogger.warn(`[extractChainOfThought] Could not extract chain of thought with any pattern`);\n\n  // If the response is longer than 500 characters, take the first 40% as a best guess\n  if (text.length > 500) {\n    const firstPortion = text.substring(0, Math.floor(text.length * 0.4));\n    elizaLogger.info(`[extractChainOfThought] Using first 40% of response as fallback`);\n    return `[Auto-extracted] ${firstPortion}`;\n  }\n\n  // If all else fails, indicate that we couldn't extract anything meaningful\n  return '[Could not extract chain of thought]';\n}\n\nexport const cotProvider: Provider = {\n  get: async (runtime: IAgentRuntime, message: Memory, _state?: State): Promise<string> => {\n    const logPrefix = `[CoT Provider]`;\n    elizaLogger.info(`${logPrefix} Starting chain-of-thought generation`);\n\n    try {\n      let state = _state;\n      if (!state) {\n        state = (await runtime.composeState(message)) as State;\n      } else {\n        state = await runtime.updateRecentMessageState(state);\n      }\n\n      runtime.character.system = systemPrompt;\n\n      state.actions = `# Actions \\n${JSON.stringify(runtime.actions)}`;\n\n      const context = composeContext({\n        state,\n        template: messageHandlerTemplate,\n      });\n\n      // Generate text using the chain-of-thought‚Äìenabled system prompt\n      elizaLogger.info(`${logPrefix} Generating text with LLM model`);\n      const gen = await generateText({\n        runtime,\n        context,\n        modelClass: ModelClass.LARGE,\n      });\n      elizaLogger.info(`${logPrefix} Text generation complete`);\n\n      // Log a preview of the response for debugging\n      const previewLength = Math.min(gen.length, 500);\n      elizaLogger.info(`${logPrefix} Response preview: ${gen.substring(0, previewLength)}...`);\n\n      // Extract the chain of thought using REASONING/ANSWER markers\n      let chainOfThoughtText = extractChainOfThought(gen);\n\n      // Get user message text safely\n      const userMessageText =\n        message.content && typeof message.content === 'object' && message.content.text\n          ? message.content.text\n          : typeof message.content === 'string'\n            ? message.content\n            : '';\n\n      // Format log data for storage\n      const logData = {\n        userId: message.userId,\n        agentId: message.agentId,\n        userMessage: userMessageText,\n        log: chainOfThoughtText,\n        timestamp: new Date().toISOString(),\n      };\n\n      // Store the log using the appropriate database-specific function\n      try {\n        const dbAdapter = runtime.databaseAdapter as any;\n\n        if ('pool' in dbAdapter) {\n          // PostgreSQL\n          elizaLogger.info(`${logPrefix} Using PostgreSQL to log chain-of-thought`);\n          await logMemoryPostgres(dbAdapter.pool, {\n            userId: message.userId,\n            agentId: message.agentId,\n            roomId: message.roomId,\n            type: 'chain-of-thought',\n            body: JSON.stringify(logData),\n          });\n          elizaLogger.info(`${logPrefix} Successfully logged chain-of-thought to PostgreSQL`);\n        } else if ('db' in dbAdapter) {\n          // SQLite\n          elizaLogger.info(`${logPrefix} Using SQLite to log chain-of-thought`);\n          await logMemorySqlite(dbAdapter.db, {\n            userId: message.userId,\n            agentId: message.agentId,\n            roomId: message.roomId,\n            type: 'chain-of-thought',\n            body: JSON.stringify(logData),\n          });\n          elizaLogger.info(`${logPrefix} Successfully logged chain-of-thought to SQLite`);\n        } else {\n          elizaLogger.error(`${logPrefix} Unsupported database adapter type`);\n        }\n      } catch (dbError) {\n        elizaLogger.error(`${logPrefix} Database error while saving CoT log: ${dbError.message}`);\n        elizaLogger.error(`${logPrefix} Error details:`, dbError);\n      }\n\n      elizaLogger.info(`${logPrefix} Chain-of-thought processing complete`);\n      return chainOfThoughtText || '';\n    } catch (error) {\n      elizaLogger.error(`${logPrefix} Error in chain-of-thought provider:`);\n      elizaLogger.error(`${logPrefix} ${error instanceof Error ? error.stack : 'Unknown error'}`);\n      return '';\n    }\n  },\n};\n","import { Plugin } from '@elizaos/core';\nimport { RecallService } from './services/recall.service.ts';\nimport { buyCreditAction } from './actions/buy-credit.ts';\nimport { getCreditBalanceAction } from './actions/get-balance.ts';\nimport { getAccountInfoAction } from './actions/get-account.ts';\nimport { listBucketsAction } from './actions/list-buckets.ts';\nimport { createBucketAction } from './actions/create-bucket.ts';\nimport { addObjectAction } from './actions/add-object.ts';\nimport { getObjectAction } from './actions/get-object.ts';\nimport { cotProvider } from './providers/cot.ts';\n// import { recallCotProvider } from './providers/index.ts';\n\nexport const recallStoragePlugin: Plugin = {\n  name: 'Recall Storage Plugin',\n  description: 'Provides basic Recall storage functionality',\n  actions: [\n    buyCreditAction,\n    getCreditBalanceAction,\n    getAccountInfoAction,\n    listBucketsAction,\n    addObjectAction,\n    getObjectAction,\n    createBucketAction,\n  ],\n  providers: [cotProvider],\n  services: [RecallService.getInstance()],\n};\n\nexport default recallStoragePlugin;\n"],"mappings":"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","names":["elizaLogger","elizaLogger","batchSize","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","elizaLogger","fs","path","elizaLogger","elizaLogger"]}